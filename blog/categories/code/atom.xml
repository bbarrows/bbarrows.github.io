<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Code | Haxin Mainframes]]></title>
  <link href="http://bbarrows.github.com/blog/categories/code/atom.xml" rel="self"/>
  <link href="http://bbarrows.github.com/"/>
  <updated>2014-11-05T14:12:14-08:00</updated>
  <id>http://bbarrows.github.com/</id>
  <author>
    <name><![CDATA[Brad Barrows]]></name>
    <email><![CDATA[bradleyb1537@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Installing OpenCL and PyOpenCL on Ubuntu 12.10]]></title>
    <link href="http://bbarrows.github.com/blog/2012/09/24/opencl-on-ubuntu-1210/"/>
    <updated>2012-09-24T22:47:00-07:00</updated>
    <id>http://bbarrows.github.com/blog/2012/09/24/opencl-on-ubuntu-1210</id>
    <content type="html"><![CDATA[<h1>The hassle of Intel OpenCL Dev</h1>

<h2>Trying to mine some damn bitcoin</h2>

<p>Fueled by the ridiculous BitCoin bubble and yes, I know, late to the game I decided I might as well start a bitcoin miner on an extra computer or two.</p>

<p>What I didnt expect is the huge pain in the ass that was installing the Intel OpenCL libs/headers..</p>

<p>Ill try to sum this up as quickly as possible:</p>

<p>I started with <a href="http://develnoter.blogspot.com/2012/05/installing-opencl-in-ubuntu-1204.html">this guys blog entry on installing OpenCL on ubuntu</a> which</p>

<p>This is directly from his site, slightly modified:</p>

<hr />

<ol>
<li>Download the <a href="http://software.intel.com/en-us/articles/vcsource-tools-opencl-sdk/">Intel SDK for OpenCL Applications from Intel&rsquo;s web site</a>. The download options are not easy to spot in the messy page, they are on the top right bo. After downloading, you will end with a .tgz file with an RPM inside (crazy, I know).</li>
</ol>


<p>The guy who I stole this walk through from says he got the file :
    intel_sdk_for_ocl_applications_2012_x64.tgz.
NOTE!! I actually didnt see this option I downloaded the option with all the check marks for the beta that supported RedHat Linux. I got this file:
    intel_sdk_for_ocl_applications_2013_xe_beta_sdk_3.0.56860_x64.tgz</p>

<ol>
<li>Extract the RPM from the .tgz file:
 $ tar zxvf intel_sdk_for_ocl_applications_2012_x64.tgz</li>
</ol>


<p>This will extract the intel_ocl_sdk_2012_x64.rpm file.</p>

<ol>
<li>Convert the RPM file to .deb format and install:
 $ sudo apt-get install -y rpm alien libnuma1    # In case you don&rsquo;t have these packages
 $ fakeroot alien &ndash;to-deb intel_ocl_sdk_2012_x64.rpm</li>
</ol>


<p>The guy says to run:</p>

<pre><code>$ sudo dpkg -i intel-ocl-sdk_2.0-31361_amd64.deb
</code></pre>

<p>However you will probably have 4 diff debs. I just ran the following to install them all:
sudo dpkg -i *.deb</p>

<ol>
<li>Now the SDK and libraries will be installed to /usr/lib64, while Ubuntu expects them to be in /usr/lib. No problem, just make a symlink and update the library cache:
 $ sudo ln -s /usr/lib64/libOpenCL.so /usr/lib/libOpenCL.so
 $ sudo ldconfig</li>
</ol>


<p>That&rsquo;s it! OpenCL should be installed now. Let&rsquo;s try with a test program to see the device capabilities.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;CL/cl.hpp&gt;
#include &lt;boost/foreach.hpp&gt;

int main(int, char**) {
 std::vector&lt;cl::Platform&gt; platforms;
 cl::Platform::get(&amp;platforms);
 BOOST_FOREACH(cl::Platform platform, platforms) {
     std::cout &lt;&lt; "Platform: " &lt;&lt; platform.getInfo&lt;CL_PLATFORM_NAME&gt;() &lt;&lt; std::endl;
     std::vector&lt;cl::Device&gt; devices;
     platform.getDevices(CL_DEVICE_TYPE_GPU | CL_DEVICE_TYPE_CPU, &amp;devices);
     BOOST_FOREACH(cl::Device device, devices) {
         std::cout &lt;&lt; "Device: " &lt;&lt; device.getInfo&lt;CL_DEVICE_TYPE&gt;();
         std::cout &lt;&lt; " (" &lt;&lt; CL_DEVICE_TYPE_GPU &lt;&lt; " means GPU, " &lt;&lt; CL_DEVICE_TYPE_CPU &lt;&lt; " means CPU)" &lt;&lt; std::endl;
     }
 }
}
</code></pre>

<p>Save this snippet into opencl.cpp, compile and run:
$ g++ opencl.cpp -lOpenCL -o opencl &amp;&amp; ./opencl
Platform: Intel&reg; OpenCL
Device: 2 (4 means GPU, 2 means CPU)
This shows that this particular machine has one OpenCL-capable Intel CPU.</p>

<hr />

<p>So continuing on I basically kep trying to compile his example until it succesfully compiled and ran.</p>

<p>So along with installing the libs I needed the headers to do this I made the following dir:</p>

<pre><code>sudo mkdir -p /usr/local/cuda/include/CL
cd /usr/local/cuda/include/CL
sudo wget http://www.khronos.org/registry/cl/api/1.1/cl.hpp
sudo wget http://www.khronos.org/registry/cl/api/1.1/cl.h
sudo wget http://www.khronos.org/registry/cl/api/1.1/opencl.h
sudo wget http://www.khronos.org/registry/cl/api/1.1/cl_platform.h
sudo wget http://www.khronos.org/registry/cl/api/1.1/cl_gl.h
sudo wget http://www.khronos.org/registry/cl/api/1.1/cl_gl_ext.h
sudo wget http://www.khronos.org/registry/cl/api/1.1/cl_ext.h
sudo chmod -R a+r /usr/local/cuda
</code></pre>

<p>If you are missing any other headers try looking for the file under the
    <a href="http://www.khronos.org/registry/cl/api/1.1/">http://www.khronos.org/registry/cl/api/1.1/</a>
directory..</p>

<p>I also installed:</p>

<p>sudo apt-get install libboost-all-dev python-setuptools python-numpy</p>

<p>I actually installed numpy with pip but that should work too..</p>

<p>I downloaded <a href="https://pypi.python.org/pypi/pyopencl">PyOpenCL</a> and ran
    sudo python setup.py install
however it couldnt find the headers.</p>

<p>I actually just added the following line to setup.py, right before the line:
    INCLUDE_DIRS = conf[&ldquo;BOOST_INC_DIR&rdquo;] + conf[&ldquo;CL_INC_DIR&rdquo;]
I added:
    conf[&ldquo;CL_INC_DIR&rdquo;] = [&lsquo;/usr/local/cuda/include/&rsquo;, &lsquo;/usr/local/cuda/include/CL&rsquo;]</p>

<p>althouh you prob only need that first one..</p>

<p>then running:
    sudo python setup.py install
worked great..</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Implementing Exception Logging in Python]]></title>
    <link href="http://bbarrows.github.com/blog/2012/09/24/implementing-exception-logging-in-python/"/>
    <updated>2012-09-24T22:47:00-07:00</updated>
    <id>http://bbarrows.github.com/blog/2012/09/24/implementing-exception-logging-in-python</id>
    <content type="html"><![CDATA[<p>
When tasked with logging all the exceptions that our software might encounter in the wild I tried a number of different techniques to log our python exception tracebacks. I ended up with an application that would take logs of a specific level and upload them to a server (in our case Loggly) where we could analyze them.
</p>




<p> The first hurdle was determing how I could install my own method to process and log ALL tracebacks happening in the application.
</p>




<p>
At first I thought that the python system exception hook, <a href="http://docs.python.org/library/sys.html">sys.excepthook</a> would be the perfect place to insert the logging code. I was trying something similar to:
</p>


<pre>
import traceback
import StringIO
import logging
import os, sys

def my_excepthook(excType, excValue, traceback, logger=logger):
    logger.error("Logging an uncaught exception", exc_info=(excType, excValue, traceback))

sys.excepthook = my_excepthook
</pre>


<p>
This worked for the main thread but I soon found that the my sys.excepthook would not exist across any new threads my process started. This is a huge issue because most everything happens in threads in this project.
</p>


<p>
After googling and reading plenty of documentation the most helpful information I found was from the <a href="http://bugs.python.org/issue1230540">Python Issue tracker</a>.
</p>


<p>
The first post on the thread shows a working example of the sys.excepthook NOT persisting across threads (as shown below). Apparently this is expected behavior.
</p>


<pre>
import sys, threading

def log_exception(*args):
    print 'got exception %s' % (args,)
sys.excepthook = log_exception

def foo():
    a = 1 / 0
threading.Thread(target=foo).start()
</pre>




<p>The messages on this Python Issue thread really result in 2 suggested hacks. Either subclass Thread and wrap the run method in our own try except block in order to catch and log exceptions or monkey patch threading.Thread.run to run in your own try except block and log the exceptions.</p>


<p>The first method of subclassing Thread seems to me to be less elegant in your code as you would have to import and use your custom Thread class EVERYWHERE you wanted to have a logging thread. This ended up being a hassle because I had to search our entire code base and replace all normal Threads with this custom Thread. However, it was clear as to what this Thread was doing and would be easier for someone to diagnose and debug if something went wrong with the custom logging code. A custom logging thread might look like this: </p>




<pre>
class TracebackLoggingThread(threading.Thread):
    def run(self):
        try:
            super(TracebackLoggingThread, self).run()
        except (KeyboardInterrupt, SystemExit):
            raise
        except Exception, e:
            logger = logging.getLogger('')
            logger.exception("Logging an uncaught exception")
</pre>




<p>The second method of monkey patching threading.Thread.run is nice because I could just run it once right after __main__ and instrument my logging code in all exceptions. Monkey patching can be annoying to debug though as it changes the expected functionality without being obvious that this was done. The suggested patch from the Python Issue tracker was: </p>




<pre>
def installThreadExcepthook():
    """
    Workaround for sys.excepthook thread bug
    From
http://spyced.blogspot.com/2007/06/workaround-for-sysexcepthook-bug.html

    Call once from __main__ before creating any threads.
    If using psyco, call psyco.cannotcompile(threading.Thread.run)
    since this replaces a new-style class method.
    """
    init_old = threading.Thread.__init__
    def init(self, *args, **kwargs):
        init_old(self, *args, **kwargs)
        run_old = self.run
        def run_with_except_hook(*args, **kw):
            try:
                run_old(*args, **kw)
            except (KeyboardInterrupt, SystemExit):
                raise
            except:
                sys.excepthook(*sys.exc_info())
        self.run = run_with_except_hook
    threading.Thread.__init__ = init
</pre>




<p>The main goal of creating somethign that could log any of our tracebacks was to send these tracebacks up a server where we could search through issues people were having in the wild and find bugs in our software.
    It was not until I started testing my exception logging I realized that I was going about it all wrong.</p>




<p>To test I had placed a <pre>raise Exception("Test")</pre> and/or a <pre>1/0</pre> somewhere in my code. However, wrapping a a method that called this method was a try except block that printed out the traceback and swallowed the exception. This was very frustrating because I saw the traceback bring printed using logging.error but not being processed by my custom exception handler. My exception handlers purpose was to take these tracebacks and ultimately upload them to a server. </p>




<p>The final implementation consisted of a few different classes that looked something like this:</p>




<pre>
class CustomLoggingfThread(Thread):
    def __init__(self, daemon_thread=False, group=None, target=None, name="LiveThread",
                 args=(), kwargs={}, verbose=None, clean_up=None):
        self.args = args
        self.kwargs = kwargs

        # This will make sure that the thread is wrapped in the try except block
        #regardless of whather or not you extend the class are use the target invocation
        #of Thread
        if type(self) != LiveThread:
            assert hasattr(self,"run")
            self.target = self.run
        else:
            self.target = target
        Thread.__init__(self, group=group, target=target, name=name,
                 args=args, kwargs=kwargs, verbose=verbose)
        self.run = self.__run
        self.daemon = daemon_thread


    def __run(self):
        try:
            self.target(*self.args, **self.kwargs)
        except Exception:
            logging.error("The thread %s raised an exception." % self.name, exc_info=True)
            #We consider exiting our application here if its an important thread that crashed and can't
            #be restarted.

</pre>




<p>
As you can see, our custom logging thread became VERY simple. It just wraps the threaded function in a try except block and logs any tracebacks to logging.error
</p>




<p>This class is meant to be used in combination with our custom logging filter and handlers. The python Logging module provides some great tools to help you control what you do with your logging. My implementation looked something like this:
</p>




<pre>


class CustomLoggingFilter(logging.Filter):
    def filter(self, record):
        return record.levelno >= logging.WARNING

class CustomLogglyHttpHandler(hoover.LogglyHttpHandler):

...
    Removed some code to be brief..
...

    def emit(self, record):
        if isinstance(record.msg, (list, dict)):
            record.msg = dumps(record.msg, cls=self.json_class, default=str)
        msg = self.format(record)
        self.synchronous_loggly_post(msg)



loggly_handler = CustomLogglyHttpHandler(.....some args....)
loggly_handler.addFilter(CustomLoggingFilter())

#Get the root logger so all log msgs run through our handler/filter
loggly_logger = logging.getLogger('')
loggly_logger.addHandler(loggly_handler)

</pre>




<p>
The above code is really what puts this all together. It adds a logging handler to post only the log messages of a certian log level (via a filter) to the server.

In the actuall implementation we do a few things such as buffering of the log messages as well. These were left out to keep the post short(er).
</p>

]]></content>
  </entry>
  
</feed>
