<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Haxin Mainframes]]></title>
  <link href="http://bbarrows.github.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://bbarrows.github.com/"/>
  <updated>2014-11-05T14:18:04-08:00</updated>
  <id>http://bbarrows.github.com/</id>
  <author>
    <name><![CDATA[Brad Barrows]]></name>
    <email><![CDATA[bradleyb1537@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Random Idea About Language Implementation and Strings]]></title>
    <link href="http://bbarrows.github.com/blog/2012/10/29/string-idea/"/>
    <updated>2012-10-29T22:30:00-07:00</updated>
    <id>http://bbarrows.github.com/blog/2012/10/29/string-idea</id>
    <content type="html"><![CDATA[<p>I was reading this awesome post about why this guy <a href="http://www.evanmiller.org/why-i-program-in-erlang.html">appreciates erlang</a>.</p>

<p>And this paragraph caught my eye.</p>

<hr />

<p>Or take string concatenation. If you pop open the implementation of string concatenation in Perl, Ruby, or JavaScript, you&rsquo;ll are certain to find an if statement, a realloc, and a memcpy. That is, when you concatenate two strings, the first string is grown to make room for the second, and then the second is copied into the first. This approach has worked for decades and is the “obvious” thing to do. Erlang&rsquo;s approach is non-obvious, and, I believe, correct. Erlang does not use a contiguous chunk of memory to represent a sequence of bytes. Instead, it represents a sequence of bytes as nested lists of non-contiguous chunks of memory. The result is that concatenating two strings takes O(1) time in Erlang, compared O(N) time in other languages. This is why template rendering in Ruby, Python, etc. is slow, but very fast in Erlang.</p>

<hr />

<p>I just thought it would be a cool little mini project to try and re implement Python and or Ruby strings to act like Erlang strings (the linked list of bytes versus contiguous). I am kind of using this as a note to myself since writing things down in other places just gets lost a lot of the time..</p>

<p>It would be cool to do this though and then compare the new ruby build with the previous in a bunch of different speed string tests.</p>

<p>After talking to some friends at work I realized that this already done. Using the rope data structure. A cool implementation, <a href="https://github.com/josephg/librope">librope</a> is a very interesting read.</p>

<p>After checking the librope implementation out I realized that using these strings would only be a benfit in very specific situations, long modifiable strings.</p>

<p>However, having an implementation accessbile in a standard library would deff be a cool thing to have. I could see this being super helpful when doing something like building a website response from templates.</p>

<p>Actually from a quick google it sounds like this is how PyPy implemented strings.</p>
]]></content>
  </entry>
  
</feed>
