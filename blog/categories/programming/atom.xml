<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programming | Haxin Mainframes]]></title>
  <link href="http://bbarrows.github.com/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://bbarrows.github.com/"/>
  <updated>2014-11-05T14:12:14-08:00</updated>
  <id>http://bbarrows.github.com/</id>
  <author>
    <name><![CDATA[Brad Barrows]]></name>
    <email><![CDATA[bradleyb1537@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using UDP in the Python Tornado Framework]]></title>
    <link href="http://bbarrows.github.com/blog/2013/01/27/udptornado/"/>
    <updated>2013-01-27T12:48:00-08:00</updated>
    <id>http://bbarrows.github.com/blog/2013/01/27/udptornado</id>
    <content type="html"><![CDATA[<p>A little while ago I was working on an API endpoint that needed to ask the BitTorrent Live video streaming trackers how many people were watching what swarms. I needed to do this by sending the byte 4 to the tracker on a certain ip and port. We were using Tornado. Previously to use UDP sockets with the Tornado event loop (in my python DHT project for example) I just created a non blocking UDP socket and added a handler for the READ state.</p>

<pre><code>self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
self.io_loop.add_handler(self.sock.fileno(), self.handle_input, self.io_loop.READ)

udpsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
udpsock.setblocking(0)
</code></pre>

<p>The callback for this handler looked like this:</p>

<pre><code>def handle_input(self, fd, events):
    (data, source_ip_port) = self.sock.recvfrom(4096)
    bdict = bdecode(data)

    #Got a response from some previous query
    if bdict["y"] == "r":
        self.handle_response(bdict, source_ip_port)

    #Porb gonna have to ad a listenr socket
    #Got a query for something
    if bdict["y"] == "q":
        self.handle_query(bdict, source_ip_port)
</code></pre>

<p>I believe this is an appropriate way to handle UDP sockets in Tornado (as the library only comes with TCP/HTTP based clients I know of..). However my friend <a href="http://kyle.graehl.org/">Kyle Grahel</a> put together a nice <a href="http://kyle.graehl.org/coding/2012/12/07/tornado-udpstream.html">UDP Wrapper</a> class that is much closer to and even takes methods from the general Tornado IOStream class.</p>

<p>Using the UDPWrapper I was able to do something like this (I actually added an enter and exit for the with however I am not sure if its actually very pythonic to do it that way versus try finally):</p>

<pre><code>udpsockwrapper = UDPSockWrapper(udpsock, in_ioloop=io_loop)
response = None
with udpsockwrapper:
    udpsockwrapper.sendto(chr(4), (tracker_ip, int(tracker_port)))
    response = yield gen.Task(udpsockwrapper.read_chunk)
</code></pre>

<p>You may notice the yield gen.Task above? This is using Tornado&rsquo;s awesome gen library. It basically allows you to turn your functions into generators which the event loop basically iterates through as it hits your callbacks. This allows you to take your nested callback code and turn it into a synchronous style. I believe this is similar to the Deferred class you yield with in the Twisted framework.</p>

<p>My modified version of the UDPWrapper:</p>

<pre><code>import tornado, time

#From Kyle Grahel - http://kyle.graehl.org/
#The __enter__ and __exit__ are added by me.. probably not the best way to use
#these though..
class UDPSockWrapper(object):
    def __enter__(self):
        return

    def __exit__(self, type, value, traceback):
        self.close()

    def __init__(self, socket, in_ioloop=None):
        self.socket = socket
        self._state = None
        self._read_callback = None
        self.ioloop = in_ioloop or tornado.ioloop.IOLoop.instance()

    def __repr__(self):
        return "&lt;UDPSockWrap:%s,rc:%s&gt;" % (self.socket.fileno(), self._read_callback)

    def _add_io_state(self, state):
        if self._state is None:
            self._state = tornado.ioloop.IOLoop.ERROR | state
            #with stack_context.NullContext():
            self.ioloop.add_handler(
                self.socket.fileno(), self._handle_events, self._state)
        elif not self._state &amp; state:
            self._state = self._state | state
            self.ioloop.update_handler(self.socket.fileno(), self._state)

    def sendto(self, msg, dest):
        return self.socket.sendto(msg, dest)

    def recv(self,sz):
        return self.socket.recv(sz)

    def close(self):
        self.ioloop.remove_handler(self.socket.fileno())
        self.socket.close()
        self.socket = None

    def read_chunk(self, callback=None, timeout=4):
        self._read_callback = callback
        self._read_timeout = self.ioloop.add_timeout( time.time() + timeout, 
            self.check_read_callback )
        self._add_io_state(self.ioloop.READ)

    def check_read_callback(self):
        if self._read_callback:
            # XXX close socket?
            #data = self.socket.recv(4096)
            self._read_callback(None, error='timeout')

    def _handle_read(self):
        if self._read_timeout:
            self.ioloop.remove_timeout(self._read_timeout)
        if self._read_callback:
            try:
                data = self.socket.recv(4096)
            except:
                # conn refused??
                data = None
            self._read_callback(data);
            self._read_callback = None

    def _handle_events(self, fd, events):
        if events &amp; self.ioloop.READ:
            self._handle_read()
        if events &amp; self.ioloop.ERROR:
            logging.error('%s event error' % self)
</code></pre>

<p>Another side note is that read_chunk above has the keyword argument callback. This is a requirement for the gen.Task class. The function that it executes should have a keyword argument callback=None. In order to convert any function to a function with this callback kwarg I used this lambda:</p>

<pre><code>lambda **kwargs: db.get_item('users', {"HashKeyElement": {"S": username}}, kwargs['callback'])
</code></pre>

<p>You can then use them in gen.Task:</p>

<pre><code>yield gen.Task(
            lambda **kwargs: db.get_item('users', {"HashKeyElement": {"S": username}}, kwargs['callback']))
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Open File From Console Python Traceback in Text Editor]]></title>
    <link href="http://bbarrows.github.com/blog/2013/01/27/sublimeconsole/"/>
    <updated>2013-01-27T12:48:00-08:00</updated>
    <id>http://bbarrows.github.com/blog/2013/01/27/sublimeconsole</id>
    <content type="html"><![CDATA[<p>Often when I am programming I want to be able to quickly find a function/class definition when I hit a traceback. My normal dev environment is basically just Sublime Text 2 and the OSX console. My Co-Worker Brahm Cohan figured out a cool trick the other day from one of his friends I believe.</p>

<p>Basically, you:</p>

<p>Open, the Automator app. Create a new &ldquo;Service&rdquo;.</p>

<p><img src="/images/automator.png" alt="Service Project in Automator" /></p>

<p>The service should execute the following (you can replace Sublime with whatever editor you use):</p>

<p>open -a Sublime\ Text\ 2 $1</p>

<p><img src="/images/service.png" alt="Sublime Text command" /></p>

<p>Then open up System Preferences. Goto Keyboard under the Keyboard Shortcuts menu scroll down to find your new service. I named mine tosublime and set the Command-L combo to run it.</p>

<p><img src="/images/preferences.png" alt="Perferences Keyboard window" /></p>

<p>Now I can select the absolute path of a file in my python tracebacks and hit Command L. This opens up the file I need to start debugging in. With a little more work I am sure you could parse out the line number too.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unlimited Vacation]]></title>
    <link href="http://bbarrows.github.com/blog/2013/01/26/vacation/"/>
    <updated>2013-01-26T12:48:00-08:00</updated>
    <id>http://bbarrows.github.com/blog/2013/01/26/vacation</id>
    <content type="html"><![CDATA[<p>I always laugh when I see jobs with unlimited vacation time. This seems like a joke to me. At any company I have ever worked for it seemed like people had vacation time rolling over from previous years or were in fear of losing it for not using it. There seems to be a guilt about using vacation time.</p>

<p>I personally am always worried about using mine, I have this illogical guilt. I feel like I needed to be around working as hard as possible as often as possible or else I will be viewed as a slacker. If anything having an alloted amount of vacation time is a blessing. It represents a company wide accepted amount of time for me to take off. If somone gave me &ldquo;unlimited vacation time&rdquo; I would never take any vacation because I would always feel like I was taking advantage, or at least like I was being percieved as un involved. It makes me wonder if companies realize this and use this &ldquo;benefit&rdquo; to their advantage.</p>

<p>I would love to hear from anyone working at a company with this benefit and hear about the politics behind using it.</p>

<h2>Points from comments here and hacker news</h2>


<p>It was great to see so many different points of view in the comments both here and on Hacker News. After reading a few I felt I should clairify my reasoning a little.</p>

<p>The &ldquo;Unlimited Vacation&rdquo; benefit seems to be more advantageous for companies and possibly misleading for the employees. This [article])(<a href="http://finance.yahoo.com/blogs/the-exchange/unlimited-vacation-time-ultimate-benefit-160807503.html">http://finance.yahoo.com/blogs/the-exchange/unlimited-vacation-time-ultimate-benefit-160807503.html</a>) makes the claim that with the unlimited vacation benefit the limiting factor is really &ldquo;can you get your work done?&rdquo; The ironic thing is that in any smaller tech company, which are the companies I see offering this, there is always work to be done. There has never been a point in the last two years where I personally felt like it was a good time to take a vacation. There has always been some feature we imminently needed. Point being, theres always work to be done so there&rsquo;s rarely a good time to take advantage of your &ldquo;unlimited vacation&rdquo;.</p>

<p>It also saves the company a full paycheck or so when the employee leaves. As anemitz (a Hacker News commenter) pointed out:</p>

<p>&ldquo;Another less likely employer benefit to be considered is that in roughly half of that U.S. states, employers must pay out accrued vacation time if there is a policy in place.</p>

<p>An example from California&rsquo;s vacation faq (<a href="http://www.dir.ca.gov/dlse/faq_vacation.htm">http://www.dir.ca.gov/dlse/faq_vacation.htm</a>):</p>

<p>&lsquo;For example, an employee who is entitled to three weeks of annual vacation (15 work days entitlement per year x 8 hours/day = 120 hours vacation entitlement per year) who quits on August 7, 2002 (the 219th day of the year) without having taken any vacation in 2002, who has no vacation carry-over from prior years, and whose final rate of pay is $13.00 per hour, would be entitled to $936.00 vacation pay upon separation&rsquo;
&#8221;</p>

<p>By giving employees unlimited vacation time and not giving them an alloted amount of PTO it seems like the company won&rsquo;t have to keep track and pay the employee for their remaining PTO when they leave.</p>

<p>And again, my guilt about taking a vacation. Personally, if I do not have a quantified amount of expected vacation time I will not know how much I am expected to take and probably wont take much at all.</p>

<p>On the other hand, as dvo pointed out:</p>

<p>&ldquo;
It might be a great policy, and I&rsquo;m sure it depends on the details of how it is implemented and the culture of the company where it is implemented&hellip;
&rdquo;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Surf Journal]]></title>
    <link href="http://bbarrows.github.com/blog/2012/12/14/surfjournal/"/>
    <updated>2012-12-14T19:48:00-08:00</updated>
    <id>http://bbarrows.github.com/blog/2012/12/14/surfjournal</id>
    <content type="html"><![CDATA[<p>I think there is a great opportunity to take advantage of all the great NOAA information out there provided by the government for free. With this I can use supervised learning with input from professionals and surfers using the site. I would gather professional input from the other surf forecasting sites out there and allow members to sign up and chart their own surf journals.</p>

<p>This would build surf journals for not just the popular spots like those you see on surfline but for anyspot a surfer desires. He could specify the closest booies and which area the secret spot was in and I would gather wind, tide, and swell information mostly to build a profile of the spot.</p>

<p>This blog post is actually being used as a landing page to gauge interest via a Google AdWords campaign. I will set this as the destination and hope people click through my ads. If so I know there are people interested in this idea as well.</p>
]]></content>
  </entry>
  
</feed>
